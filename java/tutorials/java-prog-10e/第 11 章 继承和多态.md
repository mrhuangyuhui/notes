[TOC]

# 第 11 章 继承和多态

## 11.1 引言

n/a

## 11.2 父类和子类

> 父类中的私有数据域在该类之外是不可访问的。因此，不能在子类中直接使用。但是，如果父类中定义了公共的访问器 / 修改器，那么可以通过这些公共的访问器 / 修改器来访问和修改它们。


> 在 Java 中是不允许多重继承的。

> 多重继承是可以通过接口来实现的。

## 11.3 使用 `super` 关键字

> 关键字 `super` 指代父类，可以用于调用父类中的普通方法和构造方法。

> 语句 `super()` 和 `super(arguments)` 必须出现在子类构造方法的第一行，这是显式调用父类构造方法的唯一方式。

> 构造方法可以调用重载的构造方法或父类的构造方法。如果它们都没有被显式地调用，编译器就会自动地将 `super()` 作为构造方法的第一条语句。

> 在任何情况下，构造一个类的实例时，将会调用沿着继承链的所有父类的构造方法。

> 一般情况下，最好能为每个类提供一个无参构造方法，以便于对该类进行扩展，同时避免错误。

## 11.4 方法重写

> 与实例方法一样，静态方法也能被继承。但是，静态方法不能被覆盖。如果父类中定义的静态方法在子类中被重新定义，那么在父类中定义的静态方法将被隐藏。可以使用语法：父类名 . 静态方法名（SuperClassName.staticMethodName）调用隐藏的静态方法。

## 11.5 方法重写与重载

n/a

## 11.6 `Object` 类及其 `toString()` 方法

n/a

## 11.7 多态

> 多态意味着父类的变量可以指向子类对象。

> 使用父类对象的地方都可以使用子类的对象。

## 11.8 动态绑定

> 方法可以在沿着继承链的多个类中实现。JVM 决定运行时调用哪个方法。

## 11.9 对象转换和 `instanceof` 运算符

> 一个好的经验是，在尝试转换之前确保该对象是另一个对象的实现。这是可以利用运算符 `instanceof` 来实现的。

> 为了能够进行通用程序设计，一个好的经验是把变量定义为父类型，这样，它就可以接收任何子类型的值。

> 对基本类型值进行转换不同于对象引用进行转换。转换基本类型值返回一个新的值。而转换一个对象引用不会创建另一个新的对象。

## 11.10 `Object` 类的 `equals` 方法

n/a

## 11.11 `ArrayList` 类

n/a

## 11.12 对于列表有用的方法

n/a

## 11.13 示例学习：自定义栈类

跳过

## 11.14 `protected` 数据和方法

> 子类可以重写它的父类的 `protected` 方法，并把它的可见性改为 `public`。但是，子类不能削弱父类中定义的方法的可访问性。

## 11.15 防止扩展和重写

> 一个被 `final` 修饰的类和方法都不能被扩展。被 `final` 修饰的数据域是一个常数。

学习结束

