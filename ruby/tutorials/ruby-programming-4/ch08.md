<!-- #ruby-class -->
<!-- omit in toc -->
# 第 8 章 类和模块

- [8.1 类是什么](#81-%e7%b1%bb%e6%98%af%e4%bb%80%e4%b9%88)
  - [8.1.1 类和实例](#811-%e7%b1%bb%e5%92%8c%e5%ae%9e%e4%be%8b)
  - [8.1.2 继承](#812-%e7%bb%a7%e6%89%bf)
- [8.2 类的创建](#82-%e7%b1%bb%e7%9a%84%e5%88%9b%e5%bb%ba)
  - [8.2.1 `class` 关键字](#821-class-%e5%85%b3%e9%94%ae%e5%ad%97)
  - [8.2.2 `initialize` 方法](#822-initialize-%e6%96%b9%e6%b3%95)
  - [8.2.3 实例变量与实例方法](#823-%e5%ae%9e%e4%be%8b%e5%8f%98%e9%87%8f%e4%b8%8e%e5%ae%9e%e4%be%8b%e6%96%b9%e6%b3%95)
  - [8.2.4 存取器](#824-%e5%ad%98%e5%8f%96%e5%99%a8)
  - [8.2.5 特殊变量 `self`](#825-%e7%89%b9%e6%ae%8a%e5%8f%98%e9%87%8f-self)
  - [8.2.6 类方法](#826-%e7%b1%bb%e6%96%b9%e6%b3%95)
  - [8.2.7 常量](#827-%e5%b8%b8%e9%87%8f)
  - [8.2.8 类变量](#828-%e7%b1%bb%e5%8f%98%e9%87%8f)
  - [8.2.9 限制方法的调用](#829-%e9%99%90%e5%88%b6%e6%96%b9%e6%b3%95%e7%9a%84%e8%b0%83%e7%94%a8)
- [8.3 扩展类](#83-%e6%89%a9%e5%b1%95%e7%b1%bb)
  - [8.3.1 在原有类的基础上添加方法](#831-%e5%9c%a8%e5%8e%9f%e6%9c%89%e7%b1%bb%e7%9a%84%e5%9f%ba%e7%a1%80%e4%b8%8a%e6%b7%bb%e5%8a%a0%e6%96%b9%e6%b3%95)
  - [8.3.2 继承](#832-%e7%bb%a7%e6%89%bf)

## 8.1 类是什么

### 8.1.1 类和实例

类表示对象的种类。Ruby 中的对象都一定属于某个类。

生成新的对象时，一般会用到各个类的 `new` 方法。

```bash
$ irb --simple-prompt
>> ary = Array.new
=> []
```

当想知道某个对象属于哪个类时，可以使用 [`obj.class`](https://rubydocs.org/d/ruby-2-0-0-p648/classes/Object.html#method-i-class) 方法。

```bash
$ irb --simple-prompt
>> ary = []
=> []
>> ary.class
=> Array
>> str = "Hello, world!"
=> "Hello, world!"
>> str.class
=> String
```

当判断某个对象是否属于某个类时，可以使用 [`obj.instance_of?(class)`](https://rubydocs.org/d/ruby-2-0-0-p648/classes/Object.html#method-i-instance_of-3F) 方法。

```bash
$ irb --simple-prompt
>> ary = []
=> []
>> str = "Hello, world!"
=> "Hello, world!"
>> ary.instance_of?(Array)
=> true
>> str.instance_of?(String)
=> true
```

[API 示例](https://rubydocs.org/d/ruby-2-0-0-p648/classes/Object.html#method-i-instance_of-3F)

```ruby
class A;     end
class B < A; end
class C < B; end

b = B.new
b.instance_of? A   #=> false
b.instance_of? B   #=> true
b.instance_of? C   #=> false
```

> 提示：根据类的继承关系反向追查对象是否属于某个类时，可以使用 [`obj.is_a?(class)`](https://rubydocs.org/d/ruby-2-0-0-p648/classes/Object.html#method-i-is_a-3F) 方法。

### 8.1.2 继承

[`BasicObject`](https://rubydocs.org/d/ruby-2-0-0-p648/classes/BasicObject.html) 类是 Ruby 中所有类的父类，它定义了作为 Ruby 对象的最基本功能。

> 提示：`BasicObject` 类是最最基础的类，甚至连一般对象需要的功能都没有定义。因此普通对象所需要的类一般都被定义为 [`Object`](https://rubydocs.org/d/ruby-2-0-0-p648/classes/Object.html) 类。字符串、数组等都是 `Object` 类的子类。

根据类的继承关系反向追查对象是否属于某个类时，可以使用 [`obj.is_a?(class)`](https://rubydocs.org/d/ruby-2-0-0-p648/classes/Object.html#method-i-is_a-3F) 方法。

```bash
$ irb --simple-prompt
>> str = "This is a String."
=> "This is a String."
>> str.is_a?(String)
=> true
>> str.is_a?(Object)
=> true
```

[API 示例](https://rubydocs.org/d/ruby-2-0-0-p648/classes/Object.html#method-i-is_a-3F)

```ruby
module M;    end
class A
  include M
end
class B < A; end
class C < B; end

b = B.new
b.is_a? A          #=> true
b.is_a? B          #=> true
b.is_a? C          #=> false
b.is_a? M          #=> true

b.kind_of? A       #=> true
b.kind_of? B       #=> true
b.kind_of? C       #=> false
b.kind_of? M       #=> true
```

## 8.2 类的创建

[`Person.rb`](codes/ch08/Person.rb)

```ruby
# 类定义
class Person
    # 初始化方法
    def initialize(name="Ruby")
        # 初始化实例变量
        @name = name
    end

    # 实例方法
    def sayHello
        # 在方法内引用实例变量
        puts "Hello, I am #{@name}!"
    end
end

# 创建实例对象
bob = Person.new("Bob");

# 调用实例对象的方法
bob.sayHello

alice = Person.new("Alice");
alice.sayHello

# new 方法省略参数
ruby = Person.new
ruby.sayHello
```

### 8.2.1 `class` 关键字

```
class 类名
    类的定义
end
```

> 注意：类名的首字母必须大写！！！

[`Person-class-name.rb`](codes/ch08/Person-class-name.rb)

```ruby
class person
end
```

```bash
$ ruby Person-class-name.rb
Person-class-name.rb:1: class/module name must be CONSTANT
```

### 8.2.2 `initialize` 方法

使用 `new` 方法生成新的对象时，`initialize` 方法会被调用，同时 `new` 方法的参数也会被原封不动地传给 `initialize` 方法。因此初始化对象时需要的处理一般都写在这个方法中。

### 8.2.3 实例变量与实例方法

以 `@` 开头的变量称为实例变量。在不同的方法中，程序会把局部变量看作是不同的变量来对待。而只要在同一个实例中，程序就可以超越方法定义，任意引用、修改实例变量的值。另外，引用未初始化的实例变量时的返回值为 `nil`。

### 8.2.4 存取器

> 注意：在 Ruby 中，从对象外部不能直接访问实例变量或对实例变量赋值，需要通过方法来访问对象的内部。

存取器的定义

定义 | 意义
---|---
`attr_reader :name` | 只读（定义 `name` 方法）
`attr_writer :name` | 只写（定义 `name=` 方法）
`attr_accessor :name` | 读写（定义以上两个方法）

自定义存取器方法

[`Person-custom-accessor.rb`](codes/ch08/Person-custom-accessor.rb)

```ruby
class Person
    def initialize(name="Ruby")
        @name = name
    end
    # Getter 方法
    def name
        @name
    end
    # Setter 方法
    def name=(name)
        @name = name
    end
end

person = Person.new("Bob")
# 读取实例变量
puts person.name

# 修改实例变量
person.name = "Robert"
puts person.name
```

使用属性来定义存取器方法

[`Person-attr-accessor.rb`](codes/ch08/Person-attr-accessor.rb)

```ruby
class Person
    attr_accessor :name

    def initialize(name="Ruby")
        @name = name
    end
end

person = Person.new("Bob")
puts person.name

person.name = "Robert"
puts person.name
```

### 8.2.5 特殊变量 `self`

在实例方法中，可以用 `self` 这个特殊的变量来引用方法的接收者。如果省略了接收者，Ruby 就会默认把 `self` 作为该方法的接收者。

[`Person-self.rb`](codes/ch08/Person-self.rb)

```ruby
class Person
    attr_accessor :name

    def initialize(name="Ruby")
        @name = name
    end

    def hi
        puts "Hi, I am #{self.name}!"
    end

    def hello
        puts "Hello, I am #{name}!"
    end
end

bob = Person.new("Bob")
bob.hi
bob.hello
```

> 注意：在方法内如果有同名的局部变量，引用实例变量时不能省略 `self`，否则，必须用 `@` 来引用实例变量！

```ruby
class Person
    attr_accessor :name

    def initialize(name="Ruby")
        @name = name
    end

    def hi
        # 同名局部变量
        name = "Python"

        # 引用的是局部变量，不是实例变量。
        puts "Hi, I am #{name}."

        # 省略 self，必须用 @ 来引用实例变量
        puts "#{@name} said hi."
    end

    def hello
        name = "Python"

        # 用 self 引用实例变量
        puts "Hello, I am #{self.name}."
    end
end

bob = Person.new("Bob")
bob.hi
bob.hello
```

### 8.2.6 类方法

方法的接收者就是类本身（类对象）的方法称为类方法。

- 在类的内部定义

[`Person-class-method-in-1.rb`](codes/ch08/Person-class-method-in-1.rb)

```ruby
# 在类的内部定义（推荐这种）
class Person
    def self.hello(name)
        puts "#{name} said hello."
    end
end

Person.hello("John")
```

[`Person-class-method-in-2.rb`](codes/ch08/Person-class-method-in-2.rb)

```ruby
# 在类的内部定义
class Person
    class << self
        def hello(name)
            puts "#{name} said hello."
        end
    end
end

Person.hello("John")
```

- 在类的外部定义

[`Person-class-method-out-1.rb`](codes/ch08/Person-class-method-out-1.rb)

```ruby
# 在类的外部定义
class Person
end

def Person.hello(name)
    puts "#{name} said hello."
end

Person.hello("John")
```

[`Person-class-method-out-2.rb`](codes/ch08/Person-class-method-out-2.rb)

```ruby
# 在类的外部定义
class Person
end

class << Person
    def hello(name)
        puts "#{name} said hello."
    end
end

Person.hello("John")
```

### 8.2.7 常量

[`HelloWorld.rb`](codes/ch08/HelloWorld.rb)

```ruby
class HelloWorld
    Version = "1.0"
end

p HelloWorld::Version
```

### 8.2.8 类变量

以 `@@`开头的变量称为类变量，类变量是该类所有实例的共享变量。与实例变量一样，从类的外部访问类变量时也需要存取器。不过，由于 `attr_accessor` 等存取器都不能使用，因此需要直接定义。

[`Person-class-variable.rb`](codes/ch08/Person-class-variable.rb)

```ruby
class Person
   @@HELLO_COUNT = 0

   def Person.HELLO_COUNT
       @@HELLO_COUNT
   end

   def initialize(name="Ruby")
       @name = name
   end

   def hello
       @@HELLO_COUNT += 1
       puts "Hello, I am #{@name}!\n"
   end
end

puts Person.HELLO_COUNT

bob = Person.new("Bob")
bob.hello
bob.hello
bob.hello

puts Person.HELLO_COUNT
```

### 8.2.9 限制方法的调用

Ruby 提供了 3 种方法访问级别：

- `public` 可以在类的外部访问
- `private` 只能在类的内部访问
- `protected` 只能在类及其子类的内部访问

[`AccTest-1.rb`](codes/ch08/AccTest-1.rb)

```ruby
class AccTest
    def pub
        puts "pub is a public method."
    end
    # 单独定义一个方法
    public :pub

    def priv
        puts "priv is a private method."
    end

    private :priv
end

acc = AccTest.new
# 可以在外部调用
acc.pub
# 不可以在外部调用，会报错。
acc.priv
```

或

[`AccTest-2.rb`](codes/ch08/AccTest-2.rb)

```ruby
class AccTest
    # 统一定义多个方法
    public

    def pub
        puts "pub is a public method."
    end

    private

    def priv
        puts "priv is a private method."
    end
end

acc = AccTest.new
acc.pub
acc.priv
```

```ruby
class Point
    # 定义存取器方法
    attr_accessor :x, :y
    # 将修改方法定义为 protected
    protected :x=, :y=

    def initialize(x=0.0, y=0.0)
        @x, @y = x, y
    end

    def swap(other)
        tmp_x, tmp_y = @x, @y
        @x, @y = other.x, other.y
        # 类的内部可以访问被定义为 protected 的修改方法 :x=
        other.x, other.y = tmp_x, tmp_y
    end
end

p0 = Point.new
p1 = Point.new(3.0, 5.0)
puts "p0: #{[p0.x, p0.y]}"
puts "p1: #{[p1.x, p1.y]}"

p0.swap(p1)
puts "p0: #{[p0.x, p0.y]}"
puts "p1: #{[p1.x, p1.y]}"

# 修改方法 :x= 被定义为 protected，外部无法访问。
p0.x = 20.0
```

## 8.3 扩展类

### 8.3.1 在原有类的基础上添加方法

Ruby 允许我们在已经定义好的类中添加方法。

[`ext_string.rb`](codes/ch08/ext_string.rb)

```ruby
class String
  def count_word
    ary = self.split(/\s+/) # 用空格分割接收者
    return ary.size # 返回分割后的数组的元素总数
  end
end

str = "Just Another Ruby Newbie"
p str.count_word #=> 4
```

### 8.3.2 继承

利用继承，我们可以在不对已有的类进行修改的前提下，通过增加新功能或**重定义已有功能**等手段来创建新的类。

语法格式

```
class 类名 < 父类名
　类定义
end
```

[`ring_array.rb`](codes/ch08/ring_array.rb)

```ruby
class RingArray < Array # 指定父类
  def [](i) # 重定义运算符 []
    idx = i % size # 计算新索引值
    super(idx) # 调用父类中同名的方法
  end
end

wday = RingArray["日", "月", "火", "水", "木", "金", "土"]
p wday[6] #=> "土"
p wday[11] #=> "木"
p wday[15] #=> "月"
p wday[-1] #=> "土"
```

利用继承，我们可以把共同的功能定义在父类，把各自独有的功能定义在子类。

定义类时没有指定父类的情况下，Ruby 会默认该类为 `Object` 类的子类。

`Object` 类提供了许多便于实际编程的方法。但在某些情况下，我们也有可能会希望使用更轻量级的类，而这时就可以使用 `BasicObject` 类。

`BasicObject` 类只提供了组成 Ruby 对象所需的最低限度的方法。类对象调用 `instance_methods` 方法后，就会以符号的形式返回该类的实例方法列表。下面我们就用这个方法来对比一下 `Object` 类和 `BasicObject` 类的实例方法。

```bash
$ irb --simple-prompt
>> Object.instance_methods=> [:nil?, :===, :=~, :!~, :eql?, :hash, :<=>, :class, :singleton_class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze, :frozen?, :to_s, :inspect, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method,
 :public_method, :define_singleton_method, :object_id, :to_enum, :enum_for, :==, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__]
>> BasicObject.instance_methods
=> [:==, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__]
```

> 注意：定义 `BasicObject` 的子类时，与 `Object` 类不同，需要明确指定 `BasicObject` 类为父类。

```ruby
class MySimpleClass < BasicObject
end
```
